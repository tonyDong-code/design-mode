一、单一职责原则：类职责明确

二、接口隔离原则：接口最小原则

三、依赖倒转原则：逻辑操作抽象，抽象描述细节，细节实现抽象

四、里氏替换原则：子类扩展父类功能，尽量不要重写覆盖（修改）

五、开闭原则：扩展功能，不修改原先代码

六、迪米特法则：逻辑独立封装

七、合成复用原则

一、单一职责原则：类职责明确
1. 基本介绍
一个类应该只负责以想职责
2. 注意事项和细节
一个类只负责一项职责，降低类的复杂度
提高类的可读性，可维护性
类功能隔离，降低变更引起的风险
通常情况下，类遵守单一职责原则，如果逻辑足够简单，类中方法很少 ，也可以只在方法层面遵守单一职责原则
3. 应用实例
案例1
public class SingleResponsibility1 {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();
        vehicle.run("摩托车");
        vehicle.run("飞机");
        vehicle.run("汽车");
    }
}
/**
 * 交通工具类
 * 方式1：
 * 1. 在方式1的run方法中违反了单一职责原则
 * 2. 解决：根绝交通工具的运行方式不同，分解成不同的类
 */
class Vehicle{
    public void run(String vehicle){
        System.out.println(vehicle + "在公路上运行！");
    }
}

案例2
public class SingleResponsibility2 {
    public static void main(String[] args) {
        RoadVehicle roadVehicle = new RoadVehicle();
        roadVehicle.run("汽车");

        AirVehicle airVehicle = new AirVehicle();
        airVehicle.run("飞机");
    }
}
/**
 * 1. 遵守单一职责原则
 * 2. 但是这样做改动非常大，即将类分解，同时需要修改客户端
 * 3. 改进：直接修改Vehicle类，改动的代码会比较小=> 方案3
 */
class RoadVehicle{
    public void run(String vehicle){
        System.out.println(vehicle + "在公路上跑！");
    }
}
class AirVehicle{
    public void run(String vehicle){
        System.out.println(vehicle + "在天上飞！");
    }
}

案例3
public class SingleResponsibility3 {
    public static void main(String[] args) {
        Vehicle3 vehicle3 = new Vehicle3();
        vehicle3.run("汽车");
        vehicle3.run("飞机");
        vehicle3.run("轮船");
    }
}
/**
 * 1. 这种修改方法没有对原来的类做大的修改，只是增肌方法
 * 2. 这里虽然没有在类级别上做到单一职责原则，但是在方法上，遵守单一职责原则
 */
class Vehicle3{
    public void run(String vehicle){
        System.out.println(vehicle + "在公路上跑！");
    }
    public void runAir(String vehicle){
        System.out.println(vehicle + "在天上飞！");
    }
    public void runWater(String vehicle){
        System.out.println(vehicle + "在水上漂！");
    }
}


二、接口隔离原则：接口最小原则
1. 基本介绍
一个类对另一个类的依赖应该建立在最小的接口上。
类A通过接口Interface1依赖类B，类C依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，则类B和D就必须实现他们不需要的方法。
可以将接口interface1拆分为几个独立的接口，类A和C分别与他们需要的接口建立依赖关系即可。

2. 应用案例
方案1，不遵守接口隔离原则
public class Segregation1 {
}
//接口
interface Interface1 {
    void operation1();
    void operation2();
    void operation3();
    void operation4();
    void operation5();
}

class B implements Interface1 {
    public void operation1() {
        System.out.println("B 实现了 operation1");
    }
    public void operation2() {
        System.out.println("B 实现了 operation2");
    }
    public void operation3() {
        System.out.println("B 实现了 operation3");
    }
    public void operation4() {
        System.out.println("B 实现了 operation4");
    }
    public void operation5() {
        System.out.println("B 实现了 operation5");
    }
}
class D implements Interface1 {
    public void operation1() {
        System.out.println("D 实现了 operation1");
    }
    public void operation2() {
        System.out.println("D 实现了 operation2");
    }
    public void operation3() {
        System.out.println("D 实现了 operation3");
    }
    public void operation4() {
        System.out.println("D 实现了  operation4");
    }
    public void  operation5()  { System.out.println("D 实现了  operation5");
    }
}
class A { //A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法
    public void depend1(Interface1 i) { i.operation1();
    }
    public void depend2(Interface1 i) { i.operation2();
    }
    public void depend3(Interface1 i) { i.operation3();
    }
}
class C { //C 类通过接口 Interface1  依赖(使用) D 类，但是只会用到 1,4,5 方法
    public void depend1(Interface1 i) { i.operation1();
    }
    public void depend4(Interface1 i) { i.operation4();
    }
    public void depend5(Interface1 i) { i.operation5();
    }
}

方案2
类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法
将接口 Interface1 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则接口 Interface1 中出现的方法，根据实际情况拆分为三个接口
接口 Interface1 中出现的方法，根据实际情况拆分为三个接口

public class Segregation2 {
    public static void main(String[] args) {
        A2 a = new A2();
        a.depend1(new B2()); // A 类通过接口去依赖 B 类
        a.depend2(new B2());
        a.depend3(new B2());
        C2 c = new C2();
        c.depend1(new D2()); // C 类通过接口去依赖(使用)D 类
        c.depend4(new D2());
        c.depend5(new D2());
    }
}
interface I1 { 
    void operation1();
}
interface I2 { 
    void operation2();
    void operation3();
}
interface I3 { 
    void operation4();
    void operation5();
}
class B2 implements I1, I2 {
    public void operation1() {
        System.out.println("B 实现了 operation1");
    }
    public void operation2() {
        System.out.println("B 实现了 operation2");
    }
    public void operation3() {
        System.out.println("B 实现了 operation3");
    }
}
class D2 implements I1, I3 { 
    public void operation1() {
        System.out.println("D 实现了  operation1");
    }
    public void  operation4()  { 
        System.out.println("D 实现了  operation4");
    }
    public void operation5() {
        System.out.println("D 实现了 operation5");
    }
}
class A2 { 
    // A 类通过接口 Interface1,Interface2 依赖(使用) B 类，但是只会用到 1,2,3 方法
    public void depend1(I1 i) {
        i.operation1();
    }
    public void depend2(I2 i) { 
        i.operation2();
    }
    public void depend3(I2 i) { 
        i.operation3();
    }
}

class C2 { 
    // C  类通过接口 Interface1,Interface3  依赖(使用) D 类，但是只会用到 1,4,5 方法
    public void depend1(I1 i) { 
        i.operation1();
    }
    public void depend4(I3 i) { 
        i.operation4();
    }
    public void depend5(I3 i) {
        i.operation5();
    }
}

三、依赖倒转原则：逻辑操作抽象，抽象描述细节，细节实现抽象
1. 基本介绍
高层模块不应该依赖底层模块，二者都应该依赖其抽象
抽象不应该以来细节，细节应该依赖抽象
依赖倒转，面向接口编程
相对于细节的多变性，抽象的东西要稳定得多。以抽象为基础搭建的架构比以细节为基础的结构要稳定得多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。
使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。
2. 应用实例：编程完成Person接受消息的功能
方案1
简单，容易想到
如果获得对象变成微信、短信等，则需要新增类，同时Person类中也要新增相应的接受方法
解决：引入一个抽象接口IReceiver，表示被接收的信息，这样Person类与IReceiver发生依赖，Email和WeiXin等各自实现IReceiver接口就可以完成WeiXin功能的扩展，无需修改原有逻辑。
public class DependecyInversion {
    public static void main(String[] args) {
        Person person = new Person();
        Email email = new Email();
        person.receive(email);
    }
}
class Email{
    public String getInfo(){
        return "电子邮件信息：hello world！";
    }
}
class Person{
    public void receive(Email email){
        System.out.println(email.getInfo());
    }
}

方案2：方便扩展，扩展接收功能无需修改原有代码
public class DependecyInversion2 {
    public static void main(String[] args) {
        Person2 person = new Person2();
        person.receive(new Email2());
        // 扩展接收微信的功能
        person.receive(new WeiXin());
    }
}
class Person2{
    // 逻辑：逻辑操作抽象，抽象描述实体，实体实现抽象
    public void receive(IReceiver receiver){
        System.out.println(receiver.getInfo());
    }
}
// 抽象：接口/抽象类
interface IReceiver{
    public String getInfo();
}
// 实体
class Email2 implements IReceiver{
    @Override
    public String getInfo() {
        return "电子邮件信息是：Hello World！";
    }
}
class WeiXin implements IReceiver{
    @Override
    public String getInfo() {
        return "微信信息是：hello girl！";
    }
}

3. 依赖关系传递的三种方式
接口传递
在需要操作接口的方法中，将实现接口的实现类作为方法形参传入。
构造方法传递
将接口作为类的成员变量之一。
在构造类时，在构造器中，通过构造器参数赋值给接口成员变量。
setter方式传递
将接口作为类的成员变量之一。
在需要使用之前，使用类实例调用setter方法为成员变量赋值。
4. 依赖倒转原则的注意事项和细节
低层模块尽量都要有抽象类和接口，或两者都有，程序稳定性更好。
变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。
继承时遵循历史替换原则。
四、里氏替换原则：子类扩展父类功能，尽量不要重写覆盖（修改）
1. 继承性的思考和说明
继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。
继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。
2. 基本介绍
如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。  
在使用继承时，遵循里氏替换原则，子类中尽量不要重写覆盖父类的方法。
public class Liskov {
    public static void main(String[] args) {
        A a = new A();
        System.out.println("11-3=" + a.func1(11, 3)); System.out.println("1-8=" + a.func1(1, 8));

        System.out.println("-----------------------");

        B b = new B();
        System.out.println("11-3=" + b.func1(11, 3));//这里本意是求出 11-3
        System.out.println("1-8=" + b.func1(1, 8));// 1-8 System.out.println("11+3+9=" + b.func2(11, 3));
    }
}
class A{
    // 返回两个数的差
    public int func1(int num1, int num2){
        return num1 - num2;
    }
}
class B extends A {
    public int func1(int num1, int num2){
        return num1 + num2;
    }
    public int func2(int num1, int num2){
        return func1(num1, num2) + 9;
    }
}


继承实际上让两个类耦合性增强了，如果一定要在一个类中使用另一个类的方法功能，可以通过聚合，组合，依赖 来解决问题。

package com.tony_dong.design_7principle.liskov;

/**
 * @ClassName Liskov2
 * @Description TODO:历史替换原则-方案2
 * @Author Tony
 * @Date 2021/3/28
 */
public class Liskov2 {
    public static void main(String[] args) {
        A2 a = new A2();
        System.out.println("11-3=" + a.func1(11, 3));
        System.out.println("1-8=" + a.func1(1, 8));
        System.out.println("-----------------------");
        B2 b = new B2();
        //因为 B 类不再继承 A 类，因此调用者，不会再 func1 是求减法
        //调用完成的功能就会很明确
        System.out.println("11+3=" + b.func1(11, 3));//这里本意是求出 11+3
        System.out.println("1+8=" + b.func1(1, 8));// 1+8 System.out.println("11+3+9=" + b.func2(11, 3));
        //使用组合仍然可以使用到 A 类相关方法
        System.out.println("11-3=" + b.func3(11, 3));// 这里本意是求出 11-3
    }
}
//创建一个更加基础的基类
class Base {
//把更加基础的方法和成员写到 Base 类
}
// A 类
class A2 extends Base {
    // 返回两个数的差
    public int func1(int num1, int num2) { return num1 - num2;
    }
}
// B 类继承了 A
// 增加了一个新功能：完成两个数相加,然后和 9 求和
class B2 extends Base {
    //如果 B 需要使用 A 类的方法,使用组合关系
    private A a = new A();
    //这里，重写了 A 类的方法,  可能是无意识
    public int func1(int a, int b) {
        return a + b;
    }
    public int func2(int a, int b) {
        return func1(a, b) + 9;
    }
    //我们仍然想使用 A 的方法
    public int func3(int a, int b) {
        return this.a.func1(a, b);
    }
}

五、开闭原则：扩展功能，不修改原先代码
1. 基本介绍
开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则。
一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。提供方可以扩展，使用方不可以修改。用抽象构建框架，用实现扩展细节。
当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。
2. 案例应用

案例1：
缺点是违反了设计模式的 ocp 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码
新增一个绘制三级形的功能，需要修改大量原有代码
package com.tony_dong.design_7principle.ocp;

public class Ocp {
    public static void main(String[] args) {
        //使用看看存在的问题
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle()); 
        graphicEditor.drawShape(new Circle());
        // 新增
        graphicEditor.drawShape(new Triangle());
    }
}
//这是一个用于绘图的类 [使用方]
class GraphicEditor {
//接收 Shape 对象，然后根据 type，来绘制不同的图形
    public void drawShape(Shape s) {
        if (s.m_type == 1) drawRectangle(s);
        else if (s.m_type == 2) drawCircle(s);
        // 新增
        else if (s.m_type == 3) drawTriangle(s);
    }
    //绘制矩形
    public void drawRectangle(Shape r) {
        System.out.println(" 绘制矩形 ");
    }
    //绘制圆形
    public void drawCircle(Shape r) {
        System.out.println(" 绘制圆形 ");
    }
    //新增：绘制三角形
    public void drawTriangle(Shape r) { 
        System.out.println(" 绘制三角形 ");
    }
}
//Shape 类，基类
class Shape {
    int m_type;
}
class Rectangle extends Shape {
    Rectangle() {
        super.m_type = 1;
    }
}
class Circle extends Shape {
    Circle() {
        super.m_type = 2;
    }
}
//新增画三角形
class Triangle extends Shape { 
    Triangle() {
        super.m_type = 3;
    }
}

方案2
package com.tony_dong.design_7principle.ocp;

/**
 * @ClassName Ocp2
 * @Description TODO:开闭原则-方案2
 * @Author Tony
 * @Date 2021/3/28
 */
public class Ocp2 {
    public static void main(String[] args) {
        //使用看看存在的问题
        GraphicEditor2 graphicEditor = new GraphicEditor2();
        graphicEditor.drawShape(new Rectangle2());
        graphicEditor.drawShape(new Circle2());
        graphicEditor.drawShape(new Triangle2());
        graphicEditor.drawShape(new OtherGraphic2());
    }
}

    //这是一个用于绘图的类 [使用方]
class GraphicEditor2 {
    //接收 Shape 对象，调用 draw 方法
    public void drawShape(Shape2 s) {
        s.draw();
    }
}

//Shape 类，基类
abstract class Shape2 {
    int m_type;
    public abstract void draw();//抽象方法
}
class Rectangle2 extends Shape2 {
    Rectangle2() {
        super.m_type = 1;
    }
    @Override
    public void draw() {
    }
}
class Circle2 extends Shape2 {
    Circle2() {
        super.m_type = 2;
    }
    @Override
    public void draw() {
        System.out.println(" 绘制圆形 ");
    }
}
//新增画三角形
class Triangle2 extends Shape2 {
    Triangle2() {
        super.m_type = 3;
    }
    @Override
    public void draw() {
// TODO Auto-generated method stub
        System.out.println(" 绘制三角形  ");
    }
}
//新增一个图形
class OtherGraphic2 extends Shape2 {
    OtherGraphic2() {
        super.m_type = 4;
    }
    @Override
    public void draw() {
        System.out.println(" 绘制其它图形 ");
    }
}

六、迪米特法则：逻辑独立封装
1. 基本介绍
一个对象应该对其他对象保持最少的了解。
类与类关系越密切，耦合度越高。
迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息
迪米特法则还有个更简单的定义：只与直接的朋友通信交互。
直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。
2. 应用实例
有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的ID
方案1
public class Demeter1 {
    public static void main(String[] args) {
        //创建了一个 SchoolManager 对象
        SchoolManager schoolManager = new SchoolManager();
        //输出学院的员工 id  和    学校总部的员工信息
        schoolManager.printAllEmployee(new CollegeManager());
    }
}
//学校总部员工类
class Employee {
    private String id;
    public void setId(String id) {
        this.id = id;
    }
    public String getId() {
        return id;
    }
}
//学院的员工类
class CollegeEmployee {
    private String id;

    public void setId(String id) {
        this.id = id;
    }
    public String getId() {
        return id;
    }
}
//管理学院员工的管理类
class CollegeManager {
    //返回学院的所有员工
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
        for (int i = 0; i < 10; i++) { //这里我们增加了 10 个员工到 list
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工 id= " + i);
            list.add(emp);
        }
        return list;
    }
}
//学校管理类
//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager
//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则
class SchoolManager {
    //返回学校总部的员工
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();
        for (int i = 0; i < 5; i++) { //这里我们增加了 5 个员工到 list
            Employee emp = new Employee();
            emp.setId("学校总部员工 id= " + i);
            list.add(emp);
        }
        return list;
    }
    //该方法完成输出学校总部和学院员工信息(id)
    void printAllEmployee(CollegeManager sub) {
    //分析问题
    //1. 这 里 的  CollegeEmployee 不是 SchoolManager 的直接朋友
    //2. CollegeEmployee 是以局部变量方式出现在 SchoolManager
    //3. 违反了 迪米特法则
    //获取到学院员工
        List<CollegeEmployee> list1 = sub.getAllEmployee();
        System.out.println("------------学院员工------------");
        for (CollegeEmployee e : list1) {
            System.out.println(e.getId());
        }
        //获取到学校总部员工
        List<Employee> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee e : list2) {
            System.out.println(e.getId());
        }
    }
}

方案2
上面设计的问题在于 SchoolManager 中，CollegeEmployee 类并不是 SchoolManager 类的直接朋友 (分析)
按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合
//客户端
public class Demeter2 {
    public static void main(String[] args) {
        System.out.println("~~~使用迪米特法则的改进~~~");
        //创建了一个 SchoolManager 对象
        SchoolManager2 schoolManager = new SchoolManager2();
        //输出学院的员工 id  和    学校总部的员工信息
        schoolManager.printAllEmployee(new CollegeManager2());
    }
}
    //学校总部员工类
class Employee2 {
    private String id;
    public void setId(String id) {
        this.id = id;
    }
    public String getId() {
        return id;
    }
}
//学院的员工类
class CollegeEmployee2 {
    private String id;
    public void setId(String id) {
        this.id = id;
    }
    public String getId() {
        return id;
    }
}
    //管理学院员工的管理类
class CollegeManager2 {
    //返回学院的所有员工
    public List<CollegeEmployee2> getAllEmployee() {
        List<CollegeEmployee2> list = new ArrayList<CollegeEmployee2>();
        for (int i = 0; i < 10; i++) { //这里我们增加了 10 个员工到 list
            CollegeEmployee2 emp = new CollegeEmployee2();
            emp.setId("学院员工 id= " + i); list.add(emp);
        }
        return list;
    }
    // 输 出 学 院 员 工 的 信 息
    public void printEmployee() {
        //获取到学院员工
        List<CollegeEmployee2> list1 = getAllEmployee();
        System.out.println("------------学院员工------------");
        for (CollegeEmployee2 e : list1) {
            System.out.println(e.getId());
        }
    }
}
//学校管理类
//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager
//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则
class SchoolManager2 {
    //返回学校总部的员工
    public List<Employee2> getAllEmployee() {
        List<Employee2> list = new ArrayList<Employee2>();
        for (int i = 0; i < 5; i++) { //这里我们增加了 5 个员工到 list
            Employee2 emp = new Employee2();
            emp.setId("学校总部员工 id= " + i); list.add(emp);
        }
        return list;
    }
    //该方法完成输出学校总部和学院员工信息(id)
    void printAllEmployee(CollegeManager2 sub) {
        //分析问题
        //1. 将输出学院的员工方法，封装到 CollegeManager
        sub.printEmployee();
        //获取到学校总部员工
        List<Employee2> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee2 e : list2) {
            System.out.println(e.getId());
        }
    }
}

3. 迪米特法则注意事项和细节
迪米特法则的核心时降低类之间的耦合。
注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系
七、合成复用原则
1. 基本介绍
原则是尽量使用合成/聚合的方式，而不是使用继承

